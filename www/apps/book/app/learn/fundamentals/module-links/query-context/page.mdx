export const metadata = {
  title: `${pageNumber} Query Context`,
}

# {metadata.title}

In this chapter, you'll learn how to pass context when retrieving data with [Query](../query/page.mdx).

## What is Query Context?

Query context is additional information you pass to Query when retrieving data. You can use it to apply custom transformations to the returned data based on the current context.

For example, consider a Blog Module with posts and authors. You can send the user's language as context to Query to retrieve posts in the user's language.

Medusa also uses Query Context to [retrieve product variants' prices based on the customer's currency](!resources!/commerce-modules/product/guides/price).

---

## How to Pass Query Context

The `query.graph` method accepts an optional `context` parameter. You can use this to pass additional context to the data model you're retrieving (for example, `post`) or its related and linked models (for example, `author`).

You can initialize a context using `QueryContext` from the Modules SDK. It accepts an object of contexts as an argument.

For example, to retrieve posts using Query while passing the user's language as context:

export const highlights1 = [
  ["8", "context", "Pass additional context to the query."],
  ["8", "QueryContext", "Create a query context."]
]

```ts highlights={highlights1}
import { QueryContext } from "@medusajs/framework/utils"

// ...

const { data } = await query.graph({
  entity: "post",
  fields: ["*"],
  context: QueryContext({
    lang: "es",
  }),
})
```

In this example, you pass a `lang` property with the value `es` in the context. You create the context using `QueryContext`.

### How to Handle Query Context

To handle the Query context passed while retrieving records of your data models, override the [generated list method](!resources!/service-factory-reference/methods/list) of the associated module's service.

For example, continuing the example above, you can override the `listPosts` method of the Blog Module's service to handle the Query context:

export const highlights2 = [
  ["11", "listPosts", "Override the generated listPosts method."],
  ["16", "context", "The context is passed as part of `filters`."],
  ["19", "super", "Use the parent's `listPosts` method to retrieve the posts."],
  ["21", "", "If the language is set in the context, you transform the titles of the posts."]
]

```ts highlights={highlights2}
import { MedusaContext, MedusaService } from "@medusajs/framework/utils"
import { Context, FindConfig } from "@medusajs/framework/types"
import Post from "./models/post"
import Author from "./models/author"

class BlogModuleService extends MedusaService({
  Post,
  Author,
}){
  // @ts-ignore
  async listPosts(
    filters?: any, 
    config?: FindConfig<any> | undefined, 
    @MedusaContext() sharedContext?: Context | undefined
  ) {
    const context = filters.context ?? {}
    delete filters.context

    let posts = await super.listPosts(filters, config, sharedContext)

    if (context.lang === "es") {
      posts = posts.map((post) => {
        return {
          ...post,
          title: post.title + " en español",
        }
      })
    }

    return posts
  }
}

export default BlogModuleService
```

In the above example, you override the generated `listPosts` method. This method receives the filters passed to `query.graph` as its first parameter. The first parameter includes a `context` property that holds the Query context alsopassed to `query.graph`.

You extract the context from `filters`, then retrieve the posts using the parent's `listPosts` method. If the language is set in the context, you transform the post titles.

All posts returned will now have their titles appended with "en español".

### Using Pagination with Query

If you pass pagination fields to `query.graph`, you must also override the [generated listAndCount method](!resources!/service-factory-reference/methods/listAndCount) in the service.

For example, following the previous example, you must override the `listAndCountPosts` method of the Blog Module's service:

```ts
import { MedusaContext, MedusaService } from "@medusajs/framework/utils"
import { Context, FindConfig } from "@medusajs/framework/types"
import Post from "./models/post"
import Author from "./models/author"

class BlogModuleService extends MedusaService({
  Post,
  Author,
}){
  // @ts-ignore
  async listAndCountPosts(
    filters?: any, 
    config?: FindConfig<any> | undefined, 
    @MedusaContext() sharedContext?: Context | undefined
  ) {
    const context = filters.context ?? {}
    delete filters.context

    const result = await super.listAndCountPosts(
      filters, 
      config, 
      sharedContext
    )

    if (context.lang === "es") {
      result[0] = result[0].map((post) => {
        return {
          ...post,
          title: post.title + " en español",
        }
      })
    }

    return result
  }
}

export default BlogModuleService
```

Now, the `listAndCountPosts` method will handle the context passed to `query.graph` when you pass pagination fields. You can also move the logic to transform the post titles to a separate method and call it from both `listPosts` and `listAndCountPosts`.

---

## Passing Query Context to Related Data Models

If you're retrieving a data model and want to pass Query context to its associated model in the same module, pass them as part of `QueryContext`'s parameter. Then, you can handle them in the same `list` method.

<Note>

To pass Query context to linked data models, check out the [next section](#passing-query-context-to-linked-data-models).

</Note>

For example, to pass a context for the post's authors:

export const highlights3 = [
  ["6", "author", "Pass a context for the author."]
]

```ts highlights={highlights3}
const { data } = await query.graph({
  entity: "post",
  fields: ["*"],
  context: QueryContext({
    lang: "es",
    author: QueryContext({
      lang: "es",
    }),
  }),
})
```

Then, in the `listPosts` method, you can handle the context for the post's authors:

export const highlights4 = [
  ["22", "context.author?.lang", "Access the author's context."]
]

```ts highlights={highlights4}
import { MedusaContext, MedusaService } from "@medusajs/framework/utils"
import { Context, FindConfig } from "@medusajs/framework/types"
import Post from "./models/post"
import Author from "./models/author"

class BlogModuleService extends MedusaService({
  Post,
  Author,
}){
  // @ts-ignore
  async listPosts(
    filters?: any, 
    config?: FindConfig<any> | undefined, 
    @MedusaContext() sharedContext?: Context | undefined
  ) {
    const context = filters.context ?? {}
    delete filters.context

    let posts = await super.listPosts(filters, config, sharedContext)

    const isPostLangEs = context.lang === "es"
    const isAuthorLangEs = context.author?.lang === "es"

    if (isPostLangEs || isAuthorLangEs) {
      posts = posts.map((post) => {
        return {
          ...post,
          title: isPostLangEs ? post.title + " en español" : post.title,
          author: {
            ...post.author,
            name: isAuthorLangEs ? post.author.name + " en español" : post.author.name,
          },
        }
      })
    }

    return posts
  }
}

export default BlogModuleService
```

The context in `filters` will also include the context for `author`, which you can use to transform the post's authors.

---

## Passing Query Context to Linked Data Models

If you're retrieving a data model and want to pass Query context to a linked model in a different module, pass an object to the `context` property instead. The object's keys should be the linked model's name, and the values should be the Query context for that linked model.

For example, consider the Product Module's `Product` data model is linked to the Blog Module's `Post` data model. You can pass context to the `Post` data model while retrieving products:

export const highlights5 = [
  ["5", "post", "Pass a context for posts."]
]

```ts highlights={highlights5}
const { data } = await query.graph({
  entity: "product",
  fields: ["*", "post.*"],
  context: {
    post: QueryContext({
      lang: "es",
    }),
  },
})
```

In this example, you retrieve products and their associated posts. You also pass Query context for `post`, indicating the customer's language.

To handle the context, override the generated `listPosts` method of the Blog Module as explained [previously](#how-to-handle-query-context).
