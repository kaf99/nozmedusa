import { ContainerRegistrationKeys, parseCorsOrigins } from "@medusajs/utils"
import type { FastifyInstance } from "fastify"
import type {
  AdditionalDataValidatorRoute,
  BodyParserConfigRoute,
  MiddlewareDescriptor,
  MiddlewareFunction,
  MiddlewareVerb,
  RouteDescriptor,
  RouteHandler,
} from "./types"

import { Logger, MedusaContainer } from "@medusajs/types"
import { configManager } from "../config"
import {
  createRequestProxy,
  createResponseProxy,
  wrapExpressHandler,
  wrapExpressMiddleware,
} from "./express-fastify-proxy"
import { MiddlewareFileLoader } from "./middleware-file-loader"
import { authenticate, AuthType } from "./middlewares"
import { ensurePublishableApiKeyMiddleware } from "./middlewares/ensure-publishable-api-key"
import { errorHandler } from "./middlewares/error-handler"
import { RoutesFinder } from "./routes-finder"
import { RoutesLoader } from "./routes-loader"
import { RoutesSorter } from "./routes-sorter"
import { RestrictedFields } from "./utils/restricted-fields"

export class ApiLoader {
  /**
   * Wrap the original route handler implementation for
   * instrumentation.
   */
  static traceRoute?: (
    handler: RouteHandler,
    route: { route: string; method: string }
  ) => RouteHandler

  /**
   * Wrap the original middleware handler implementation for
   * instrumentation.
   */
  static traceMiddleware?: (
    handler: any,
    route: { route: string; method?: string }
  ) => any

  /**
   * A Fastify instance
   * @private
   */
  readonly #app: FastifyInstance

  /**
   * Path from where to load the routes from
   * @private
   */
  readonly #sourceDirs: string[]

  readonly #logger: Logger

  constructor({
    app,
    sourceDir,
    baseRestrictedFields = [],
    container,
  }: {
    app: FastifyInstance
    sourceDir: string | string[]
    baseRestrictedFields?: string[]
    container: MedusaContainer
  }) {
    this.#app = app
    this.#sourceDirs = Array.isArray(sourceDir) ? sourceDir : [sourceDir]
    this.#assignRestrictedFields(baseRestrictedFields ?? [])
    this.#logger = container.resolve(ContainerRegistrationKeys.LOGGER)
  }

  /**
   * Loads routes, middleware, bodyParserConfig routes, routes that have
   * opted out for Auth and CORS and the error handler.
   */
  async #loadHttpResources() {
    const routesLoader = new RoutesLoader()
    const middlewareLoader = new MiddlewareFileLoader()

    for (let dir of this.#sourceDirs) {
      await routesLoader.scanDir(dir)
      await middlewareLoader.scanDir(dir)
    }

    return {
      routes: routesLoader.getRoutes(),
      routesFinder: new RoutesFinder<RouteDescriptor>(),
      middlewares: middlewareLoader.getMiddlewares(),
      errorHandler: middlewareLoader.getErrorHandler(),
      bodyParserConfigRoutes: middlewareLoader.getBodyParserConfigRoutes(),
      additionalDataValidatorRoutes:
        middlewareLoader.getAdditionalDataValidatorRoutes(),
    }
  }

  /**
   * Registers a middleware or a route handler with Fastify
   */
  #registerFastifyHandler(
    route: MiddlewareDescriptor | RouteDescriptor | RouteDescriptor
  ) {
    if ("isRoute" in route) {
      this.#logger.debug(`registering route ${route.method} ${route.matcher}`)

      const handler = ApiLoader.traceRoute
        ? ApiLoader.traceRoute(route.handler, {
            route: route.matcher,
            method: route.method,
          })
        : route.handler

      const wrappedHandler = wrapExpressHandler(handler)

      // Skip HEAD routes as Fastify auto-generates them for GET routes
      if (route.method.toUpperCase() === "HEAD") {
        this.#logger.debug(
          `Skipping HEAD route ${route.matcher} (auto-generated by Fastify)`
        )
        return
      }

      // Use method-specific registration to avoid conflicts
      const method = route.method.toLowerCase()
      if (typeof this.#app[method] === "function") {
        this.#app[method](route.matcher, wrappedHandler)
      } else {
        // Fallback to generic route registration
        this.#app.route({
          method: route.method.toUpperCase() as any,
          url: route.matcher,
          handler: wrappedHandler,
        })
      }
      return
    }

    if (!route.methods) {
      this.#logger.debug(`registering global middleware for ${route.matcher}`)

      const handler = ApiLoader.traceMiddleware
        ? ApiLoader.traceMiddleware(route.handler, {
            route: route.matcher,
          })
        : route.handler

      const wrappedHandler = wrapExpressMiddleware(
        handler as MiddlewareFunction
      )

      this.#app.addHook("preHandler", async (request, reply) => {
        if (new RegExp(route.matcher.replace(/\*/g, ".*")).test(request.url)) {
          await wrappedHandler(request, reply)
        }
      })
      return
    }

    const methods = Array.isArray(route.methods)
      ? route.methods
      : [route.methods]

    methods.forEach((method) => {
      this.#logger.debug(
        `registering route middleware ${method} ${route.matcher}`
      )

      const handler = ApiLoader.traceMiddleware
        ? ApiLoader.traceMiddleware(route.handler, {
            route: route.matcher,
            method: method,
          })
        : route.handler

      const wrappedHandler = wrapExpressMiddleware(
        handler as MiddlewareFunction
      )

      this.#app.addHook("preHandler", async (request, reply) => {
        if (
          request.method === method.toUpperCase() &&
          new RegExp(route.matcher.replace(/\*/g, ".*")).test(request.url)
        ) {
          await wrappedHandler(request, reply)
        }
      })
    })
  }

  /**
   * Registers the middleware for restricted fields
   */
  #assignRestrictedFields(baseRestrictedFields: string[]) {
    // Store restricted fields middleware
    this.#app.addHook("preHandler", async (request, _reply) => {
      const req = request as any

      if (request.url.startsWith("/store")) {
        req.restrictedFields = new RestrictedFields()
        req.restrictedFields.add(baseRestrictedFields)
      } else if (request.url.startsWith("/admin")) {
        req.restrictedFields = new RestrictedFields()
      }
    })
  }

  /**
   * Creates the options for the Cors middleware
   */
  #createCorsOptions(origin: string) {
    return {
      origin: parseCorsOrigins(origin),
      credentials: true,
    }
  }

  /**
   * Applies global cors middleware for a given prefix
   */
  #applyCorsMiddleware(
    routesFinder: RoutesFinder<RouteDescriptor>,
    namespace: string,
    toggleKey:
      | "shouldAppendAdminCors"
      | "shouldAppendAuthCors"
      | "shouldAppendStoreCors",
    corsOptions: any
  ) {
    // Apply CORS conditionally based on route configuration
    this.#app.addHook("preHandler", async (request, reply) => {
      if (!request.url.startsWith(namespace)) {
        return
      }

      let method: string = request.method
      if (request.method === "OPTIONS") {
        method =
          request.headers["access-control-request-method"] ?? request.method
      }

      const path = `${namespace}${request.url.replace(namespace, "")}`
      const matchingRoute = routesFinder.find(path, method as MiddlewareVerb)

      if (matchingRoute && matchingRoute[toggleKey] === true) {
        // Apply CORS headers manually
        const origin = corsOptions.origin
        const requestOrigin = request.headers.origin

        if (origin === true || origin === "*") {
          reply.header("Access-Control-Allow-Origin", "*")
        } else if (typeof origin === "string") {
          reply.header("Access-Control-Allow-Origin", origin)
        } else if (
          Array.isArray(origin) &&
          requestOrigin &&
          origin.includes(requestOrigin)
        ) {
          reply.header("Access-Control-Allow-Origin", requestOrigin)
        } else if (typeof origin === "function") {
          // For dynamic origins, we'll just allow all for now
          reply.header("Access-Control-Allow-Origin", requestOrigin || "*")
        }

        if (corsOptions.credentials) {
          reply.header("Access-Control-Allow-Credentials", "true")
        }

        if (request.method === "OPTIONS") {
          reply.header(
            "Access-Control-Allow-Methods",
            "GET,HEAD,PUT,PATCH,POST,DELETE"
          )
          reply.header(
            "Access-Control-Allow-Headers",
            "Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control, X-Publishable-Api-Key"
          )
          reply.code(204).send()
          return
        }
        return
      }

      this.#logger.debug(`Skipping CORS middleware ${request.method} ${path}`)
    })
  }

  /**
   * Applies the route middleware on a route. Encapsulates the logic
   * needed to pass the middleware via the trace calls
   */
  #applyAuthMiddleware(
    routesFinder: RoutesFinder<RouteDescriptor>,
    namespace: string,
    actorType: string | string[],
    authType: AuthType | AuthType[],
    options?: { allowUnauthenticated?: boolean; allowUnregistered?: boolean }
  ) {
    const logger = this.#logger
    logger.debug(`Registering auth middleware for prefix ${namespace}`)

    const originalFn = authenticate(actorType, authType, options)

    this.#app.addHook("preHandler", async (request, reply) => {
      if (!request.url.startsWith(namespace)) {
        return
      }

      const path = `${namespace}${request.url.replace(namespace, "")}`
      const matchingRoute = routesFinder.find(
        path,
        request.method as MiddlewareVerb
      )

      if (matchingRoute && matchingRoute.optedOutOfAuth) {
        logger.debug(`Skipping auth ${request.method} ${path}`)
        return
      }

      logger.debug(`Authenticating route ${request.method} ${path}`)

      // Use the proxy wrapper for Express compatibility
      const wrappedAuth = wrapExpressMiddleware(originalFn)
      await wrappedAuth(request, reply)
    })
  }

  /**
   * Apply the most specific body parser middleware to the router
   */
  #applyBodyParserMiddleware(
    namespace: string,
    routesFinder: RoutesFinder<BodyParserConfigRoute>
  ): void {
    this.#logger.debug(
      `Registering bodyparser middleware for prefix ${namespace}`
    )

    // Set up content type parsers for different body parser configurations

    // Raw body parser for routes that need buffer data
    this.#app.addContentTypeParser(
      "application/json",
      { parseAs: "buffer" },
      async (request, body) => {
        // Check if this route needs raw body based on its configuration
        const matchingRoute = routesFinder.find(
          request.url,
          request.method as MiddlewareVerb
        )
        if (
          (matchingRoute?.config &&
            typeof matchingRoute.config === "object" &&
            matchingRoute.config.preserveRawBody) ||
          matchingRoute?.config === false
        ) {
          return body
        }
        // Otherwise parse as JSON
        return JSON.parse(body.toString())
      }
    )

    // Handle other content types that might need raw parsing
    this.#app.addContentTypeParser(
      "*",
      { parseAs: "buffer" },
      async (request, body) => {
        const matchingRoute = routesFinder.find(
          request.url,
          request.method as MiddlewareVerb
        )
        if (
          (matchingRoute?.config &&
            typeof matchingRoute.config === "object" &&
            matchingRoute.config.preserveRawBody) ||
          matchingRoute?.config === false
        ) {
          return body
        }
        // Default behavior for other content types
        return body.toString()
      }
    )
  }

  /**
   * Applies the route middleware on a route. Encapsulates the logic
   * needed to pass the middleware via the trace calls
   */
  #assignAdditionalDataValidator(
    namespace: string,
    routesFinder: RoutesFinder<AdditionalDataValidatorRoute>
  ) {
    const logger = this.#logger
    logger.debug(
      `Registering assignAdditionalDataValidator middleware for prefix ${namespace}`
    )

    this.#app.addHook("preHandler", async (request, _reply) => {
      const matchingRoute = routesFinder.find(
        request.url,
        request.method as MiddlewareVerb
      )

      if (matchingRoute && matchingRoute.validator) {
        logger.debug(
          `Using validator to validate additional data on ${request.method} ${request.url}`
        )
        ;(request as any).additionalDataValidator = matchingRoute.validator
      }
    })
  }

  /**
   * Applies the middleware to authenticate the headers to contain
   * a `x-publishable-key` header
   */
  #applyStorePublishableKeyMiddleware(namespace: string) {
    this.#logger.debug(
      `Registering publishable key middleware for namespace ${namespace}`
    )

    const wrappedMiddleware = wrapExpressMiddleware(
      ensurePublishableApiKeyMiddleware as any
    )

    this.#app.addHook("preHandler", async (request, reply) => {
      if (request.url.startsWith(namespace)) {
        await wrappedMiddleware(request, reply)
      }
    })
  }

  async load() {
    const {
      errorHandler: sourceErrorHandler,
      middlewares,
      routes,
      routesFinder,
      bodyParserConfigRoutes,
      additionalDataValidatorRoutes,
    } = await this.#loadHttpResources()

    /**
     * Parse request body on all the requests and use the routes finder
     * to pick the best matching config for the given route.
     */
    const bodyParserRoutesFinder = new RoutesFinder<BodyParserConfigRoute>(
      new RoutesSorter(bodyParserConfigRoutes).sort([
        "static",
        "params",
        "regex",
        "wildcard",
        "global",
      ])
    )
    this.#applyBodyParserMiddleware("/", bodyParserRoutesFinder)

    /**
     * Use the routes finder to pick the additional data validator
     * to be applied on the current request
     */
    if (additionalDataValidatorRoutes.length) {
      const additionalDataValidatorRoutesFinder =
        new RoutesFinder<AdditionalDataValidatorRoute>(
          new RoutesSorter(additionalDataValidatorRoutes).sort([
            "static",
            "params",
            "regex",
            "wildcard",
            "global",
          ])
        )
      this.#assignAdditionalDataValidator(
        "/",
        additionalDataValidatorRoutesFinder
      )
    }

    /**
     * CORS and Auth setup for admin routes
     */
    this.#applyCorsMiddleware(
      routesFinder,
      "/admin",
      "shouldAppendAdminCors",
      this.#createCorsOptions(configManager.config.projectConfig.http.adminCors)
    )
    this.#applyAuthMiddleware(routesFinder, "/admin", "user", [
      "bearer",
      "session",
      "api-key",
    ])

    this.#applyCorsMiddleware(
      routesFinder,
      "/store",
      "shouldAppendStoreCors",
      this.#createCorsOptions(configManager.config.projectConfig.http.storeCors)
    )
    /**
     * Publishable key check, CORS and auth setup for store routes.
     */
    this.#applyStorePublishableKeyMiddleware("/store")

    this.#applyAuthMiddleware(
      routesFinder,
      "/store",
      "customer",
      ["bearer", "session"],
      {
        allowUnauthenticated: true,
      }
    )

    /**
     * Apply CORS middleware for "/auth" routes
     */
    this.#applyCorsMiddleware(
      routesFinder,
      "/auth",
      "shouldAppendAuthCors",
      this.#createCorsOptions(configManager.config.projectConfig.http.authCors)
    )

    const collectionToSort = ([] as (MiddlewareDescriptor | RouteDescriptor)[])
      .concat(middlewares)
      .concat(routes)

    const sortedRoutes = new RoutesSorter(collectionToSort).sort()
    sortedRoutes.forEach((route) => {
      if ("isRoute" in route) {
        routesFinder.add(route)
      }
      this.#registerFastifyHandler(route)
    })

    /**
     */

    /**
     * Set up 404 handler to match Express behavior
     */
    this.#app.setNotFoundHandler((request, reply) => {
      reply
        .status(404)
        .type("text/html")
        .send(`Cannot ${request.method} ${request.url}`)
    })

    /**
     * Registering error handler as the final handler
     */
    if (sourceErrorHandler) {
      this.#app.setErrorHandler(
        async (error: any, request: any, reply: any) => {
          const req = createRequestProxy(request)
          const res = createResponseProxy(reply)
          const next = (err?: any) => {
            if (err) throw err
          }
          try {
            await sourceErrorHandler(error, req, res, next)
            if (!reply.sent) {
              reply.send()
            }
          } catch (err) {
            if (!reply.sent) {
              reply.code(500).send({ error: "Internal Server Error" })
            }
          }
        }
      )
    } else {
      const defaultErrorHandler = errorHandler()
      this.#app.setErrorHandler(
        async (error: any, request: any, reply: any) => {
          const req = createRequestProxy(request)
          const res = createResponseProxy(reply)
          const next = (err?: any) => {
            if (err) throw err
          }
          try {
            await defaultErrorHandler(error, req, res, next)
            if (!reply.sent) {
              reply.send()
            }
          } catch (err) {
            if (!reply.sent) {
              reply.code(500).send({ error: "Internal Server Error" })
            }
          }
        }
      )
    }
  }
}
